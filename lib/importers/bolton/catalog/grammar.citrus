# several grammars, each with their own specs, had to be
# combined here to resolve dependencies between them

grammar Importers::Bolton::Catalog::Grammar
  include Parsers::CommonGrammar

  rule header
    /.*?CATALOGUE OF.*/ {
      {:type => :header}
    }
  end

  rule fossil_flag
    '*' s | black '*' tag_end
  end

  rule incertae_sedis_in
    italic 'incertae sedis' close_tag ' in'
  end

  rule nomen_nudum
    italic 'nomen nudum' close_tag
  end

  rule nomina_nuda
    italic 'nomina nuda' close_tag
  end

  rule nomina_nuda_in
    nomina_nuda ' in'
  end

  ##############################################################################

  rule texts
    (text* '') {
      {:type => :texts, :texts => captures[:text].map(&:value)}
    }
  end

  rule text
    (prefix:text_delimiter* the_text:(bracketed_text_elements_with_optional_period | unbracketed_text_elements)) {
      value = the_text.value
      value.merge! text_prefix: prefix.to_s if prefix && prefix != ''
      value
    }
  end

  rule bracketed_text_elements_with_optional_period
     (bracketed_text_element delimiter:'.'?) {
       value = bracketed_text_element.value
       value[:text] << {:delimiter => delimiter} if delimiter && delimiter != ''
       value
    }
  end

  rule bracketed_text_element
    parenthesized_text | bracketed_text
  end

  rule bracketed_text
     ('[' text_elements_delimited_by_period ']') {
      value = []
      value << {:opening_bracket => '['}
      value.concat text_elements_delimited_by_period.value
      value << {:closing_bracket => ']'}
      {:text => value}
    }
  end

  rule parenthesized_text
     ('(' text_elements_delimited_by_period ')') {
      value = []
      value << {:opening_parenthesis => '('}
      value.concat text_elements_delimited_by_period.value
      value << {:closing_parenthesis => ')'}
      {:text => value}
     }
  end

  rule unbracketed_text_elements
    (text_element_not_delimited_by_period+ suffix:('.'? ' '?)) {
      value = {:text => captures[:text_element_not_delimited_by_period].map(&:value)}
      value[:text_suffix] = suffix if suffix && suffix != ''
      value
    }
  end

  rule text_elements_delimited_by_period
    text_element_delimited_by_period+ {
      captures[:text_element_delimited_by_period].map(&:value)
    }
  end

  rule text_element_delimited_by_period
    (text_element delimiter:(text_delimiter | /[.] ?/)?) {
      value = text_element.value
      value.merge! :delimiter => delimiter if delimiter && delimiter != ''
      value
    }
  end

  rule text_element_not_delimited_by_period
    (text_element text_delimiter?) {
      value = text_element.value
      value.merge! :delimiter => text_delimiter if text_delimiter && text_delimiter != ''
      value
    }
  end

  rule text_element
       reference
     | taxon_text_element
     | text_phrase
     | bracketed_text_element
     | unparseable_text_element
  end

  rule unparseable_text_element
    /[^.\)\]]+/ {
      {:unparseable => to_s}
    }
  end

  rule taxon_text_element
    (taxon_label questionable:'?'?) {
       value = taxon_label.value
       value[:questionable] = true if questionable && questionable != ''
       value
    }
  end

  rule text_phrase
    ((text_word (' ' !taxon_label !reference text_word)*) | italicized_text_phrase | parenthesized_text_phrase | quoted_text_phrase) {
      {:phrase => to_s}
    }
  end

  rule italicized_text_phrase
    italic text_phrase close_tag
  end

  rule quoted_text_phrase
    /".*?"/
  end

  rule parenthesized_text_phrase
    '(' text_phrase ')'
  end

  rule italicized_phrase_with_period
    italic ('e.g'|'et al') close_tag '.'
  end

  rule italicized_term
    recte | italicized_phrase_with_period
  end

  rule text_word
    (/[[:alnum:],\-'&]+/) | italicized_term | '*'
  end

  rule text_delimiter
    /[\s:;+]/+
  end

  #######################################################################
  # would prefer to just include the reference grammar here, but
  # apparently that's not equivalent to inlining it

  rule references
    (reference ('; ' reference)*) {
      {:references => captures[:reference].map(&:value)}
    }
  end

  rule reference
    (the_reference:(unnested_reference | nested_reference) (' ' reference_note)*) {
      value = the_reference.value
      notes = captures[:reference_note]
      value[:notes] = notes.map(&:value) if notes.present?
      value[:matched_text] = to_s
      value
    }
  end

  rule reference_note
    parenthesized_reference_note | bracketed_reference_note
  end

  rule parenthesized_reference_note
    (parenthesized_text '') {
      value = parenthesized_text.value[:text]
      value.delete :opening_parenthesis => '('
      value.delete :closing_parenthesis => ')'
      value.delete :delimiter => '.'
      value
    }
  end

  rule bracketed_reference_note
    (&/\[[[:lower:]]/ bracketed_text '') {
      value = bracketed_text.value[:text]
      value.delete :opening_bracket => '['
      value.delete :closing_bracket => ']'
      value.delete :delimiter => '.'
      value << {:bracketed => true}
      value
    }
  end

  rule unnested_reference
    (ref_author_names /[:,]? / publications (', above')? (/,? / ref_forms)?) {
      value = {}
      value[:author_names] = ref_author_names.value
      value.merge! publications.value
      value[:forms] = ref_forms.value if ref_forms
      value
    }
  end

  rule publications
    (publication (', ' publication)*) {
      publications = captures[:publication].map &:value
      if publications.size == 1
        publications.first
      else
        {:publications => publications}
      end
    }
  end

  rule publication
    (citation_year /[:;] / ref_pages) {
      value = {}
      value[:year] = citation_year.value if citation_year
      value[:pages] = ref_pages.value if ref_pages
      value
    }
  end

  rule nested_reference
    (ref_author_names ', in ' nested_author_names:ref_author_names /,? / citation_year (/[:] / ref_pages)? (', above')? (' ' ref_forms)?) {
      value = {:author_names => ref_author_names.value,
               :in => {:author_names => nested_author_names.value,
                       :year => citation_year.value}
              }
      value[:pages] = ref_pages.value
      value[:forms] = ref_forms.value if ref_forms
      value
    }
  end

  rule authorship
    (authorship_reference ('; ' authorship_reference)*) {
      captures[:authorship_reference].map &:value
    }
  end

  rule authorship_reference
    reference | short_reference
  end

  rule short_reference
    (ref_author_names (' (above)')? (/,? / citation_year (': ' ref_pages )?)? (', above')? (' ' ref_forms)?) {
      value = {:author_names => ref_author_names.value}
      value[:year] = citation_year.value if citation_year
      value[:pages] = ref_pages.value if ref_pages
      value[:forms] = ref_forms.value if ref_forms
      value[:matched_text] = to_s
      value
    }
  end

  ###############################################################
  rule ref_author_names
    (ref_author_name (', ' ref_author_name)* (' & ' ref_author_name)? et_al:(/,? / et_al)?) {
      value = captures[:ref_author_name].map &:value
      value << et_al if et_al && et_al != ''
      value
    }
  end

  rule ref_author_name
    'Lepeletier de Saint-Fargeau' |
    'Rossi de Garcia' |
    ('do ' | 'de '|'De '|'Le ')? ref_author_name_word (' ' ref_author_name_word)* (/, ?/ ref_author_name_initial+)?
  end

  rule ref_author_name_word
    /[[:upper:]]|Ã–/ ref_author_name_char+ 
  end

  rule ref_author_name_initial
    ref_author_name_char '.'
  end

  rule ref_author_name_char
    /[^[:punct:][:digit:]\s]/ | /[\-\']/
  end

  ###############################################################
  rule ref_pages
    ref_page_section_with_note (/[,;] ?/ ref_page_section_with_note)*
  end

  rule ref_page_section_with_note
    ref_page_section (' '? '(' ref_parenthetical_page ')')*
  end

  rule ref_page_section
      '(pending)'
    | figs_on_page
    | ((ref_page_section_type ' '?)? ref_page_range)
    | ref_page_section_type
  end

  rule figs_on_page
    ref_page_number ' ' /figs?\./ ' ' ref_page_range
  end

  rule ref_page_section_type
    /figs?\./ | /pls?./ | 'no.' | /page\??/ | /pagination\?/
  end

  rule ref_page_range
     /\d*[[:alpha:]]-\d*[[:alpha:]]/ | (ref_page_number (/ ?- ?/ ref_page_number)?)
  end

  rule ref_page_number
      !(year /[[:alpha:]]/)
      !(year ':')
      ((number /[[:alpha:]]/?))
    | roman_number
    | /[[:upper:]]\b/
    | /e\d+/
  end

  rule ref_parenthetical_page
    ('diagnosis '? 'in key') | 'footnote' | 'in table'
  end

  ###############################################################
  rule ref_forms
    (('(' ref_form_components ')') | no_caste_given:'no caste given') {
      (ref_form_components && ref_form_components != '' ? ref_form_components : no_caste_given).to_s
    }
  end

  rule ref_form_components
    ref_form_component (' '? ref_form_component)*
  end

  rule ref_form_component
    ('"' ref_form_components '"') | ref_form_component_unquoted
  end

  rule ref_form_component_unquoted
      'caste'
    | 'wing'
    | 'no caste or sex given'
    | 'no sex or caste given'
    | ('no caste' (' given'|' mentioned')?)
    | 'ergatoid'
    | 'dwarf'
    | /[wqsm]\.?/
    | /[[:lower:]]\./
    | '?'
  end


  ###################################################################

  rule taxon_label
      family_or_subfamily_label
    | collective_group_label
    | tribe_label
    | subtribe_label
    | order_label
    | subspecies_label
    | genus_group_label
    | subgenus_label
    | species_group_epithet_label
    | species_label
  end

  ###################################################################

  rule order_or_family_name
    family_name | order_name
  end

  rule order_name
    (!/Panama|Colombia/ /[[:upper:]][[:lower:]]{2,}a/ !/\w/) {
      {:order_name => to_s}
    }
  end

  rule order_label
    order_name
  end

  rule family_group_name
    family_or_subfamily_name | tribe_name | subtribe_name
  end

  rule family_or_subfamily_name
    (/[[:upper:]][[:lower:]]{2,}ae/ !/\w/ | 'Dorylida') {
      {:family_or_subfamily_name => to_s}
    }
  end

  rule family_or_subfamily_name_uppercase
    /[[:upper:]]{3,}AE/ {
      {:family_or_subfamily_name => titleize}
    }
  end

  rule family_group_name_uppercase
    /[[:upper:]]{3,}(AE|INI)/ {
      {:family_group_name => titleize}
    }
  end

  rule family_name
    (family_or_subfamily_name '') {
      value = family_or_subfamily_name.value
      value[:family_name] = value.delete :family_or_subfamily_name
      value
    }
  end

  rule family_name_uppercase
    (family_or_subfamily_name_uppercase '') {
      value = family_or_subfamily_name_uppercase.value
      value[:family_name] = value.delete :family_or_subfamily_name
      value
    }
  end

  rule subfamily_name
    (family_or_subfamily_name '') {
      value = family_or_subfamily_name.value
      value[:subfamily_name] = value.delete :family_or_subfamily_name
      value
    }
  end

  rule family_or_subfamily_label
    (fossil_flag? (myrmiciidae | family_or_subfamily_name)) {
      value = myrmiciidae ? myrmiciidae.value : family_or_subfamily_name.value
      value[:fossil] = true if fossil_flag
      value
    }
  end

  rule family_or_subfamily_or_order_label
    (fossil_flag? name:(myrmiciidae | family_or_subfamily_name | order_name)) {
      value = name.value
      value[:fossil] = true if fossil_flag
      value
    }
  end

  rule family_label
    (family_or_subfamily_label '') {
      value = family_or_subfamily_label.value
      value[:family_name] = value.delete :family_or_subfamily_name
      value
    }
  end

  rule subfamily_label
    (family_or_subfamily_label '') {
      value = family_or_subfamily_label.value
      value[:subfamily_name] = value.delete :family_or_subfamily_name
      value
    }
  end

  rule myrmiciidae
    'Myrmiciidae (Symphyta)' {
      {:family_name => 'Myrmiciidae', :fossil => true, :suborder_name => 'Symphyta'}
     }
  end

  ###################################################################

  rule tribe_name
    (/Platythyrei\b/ | /[[:upper:]][[:lower:]]{2,}in?i/) {
      {:tribe_name => to_s}
    }
  end

  rule subtribe_name
    /[[:upper:]][[:lower:]]{2,}(ina|iti)\b/ {
      {:subtribe_name => to_s}
    }
  end

  rule tribe_label
    (fossil_flag? tribe_name (' (' sic ')')? (' ' authorship)?) {
      value = tribe_name.value
      value[:fossil] = true if fossil_flag
      value[:sic] = true if sic
      value[:authorship] = authorship.value if authorship
      value
    }
  end

  rule subtribe_label
    (fossil_flag? subtribe_name (' ' authorship)?) {
      value = subtribe_name.value
      value[:fossil] = true if fossil_flag
      value[:authorship] = authorship.value if authorship
      value
    }
  end

  ###################################################################

  rule genus_group_name
    capitalized_word {
      {:genus_group_name => to_s}
    }
  end

  rule genus_name_uppercase
    uppercase_word {
      {:genus_name => titleize}
    }
  end

  rule genus_name
    (genus_group_name '') {
      {:genus_name => genus_group_name.value[:genus_group_name]}
    }
  end

  rule genus_abbreviation
    /[[:upper:]][[:lower:]]?\./ {
      {genus_abbreviation: to_s}
    }
  end

  rule genus_name_or_abbreviation
    genus_abbreviation | genus_name
  end

  rule subgenus_epithet
    (genus_group_name '') {
      {:subgenus_epithet => genus_group_name.value[:genus_group_name]}
    }
  end

  rule subgenus_name
    (genus_name_or_abbreviation ' (' subgenus_epithet '?'? ')') {
      genus_name_or_abbreviation.value.merge subgenus_epithet.value
    }
  end

  rule genus_group_label
    (fossil_flag? italic genus_group:(subgenus_name|genus_name) close_tag (' ' authorship)?) {
      value = genus_group.value
      value[:fossil] = true if fossil_flag
      value[:authorship] = authorship.value if authorship
      value
    }
  end

  rule genus_label_uppercase
    (fossil_flag? italic genus_name_uppercase close_tag (' ' authorship)?) {
      value = genus_name_uppercase.value
      value[:fossil] = true if fossil_flag
      value[:authorship] = authorship.value if authorship
      value
    }
  end

  rule genus_label
    (genus_group_label '') {
      genus_group_label.value
    }
  end

  rule subgenus_label
    (fossil_flag? italic genus_name_or_abbreviation ' (' fossil_flag? subgenus_epithet ')' close_tag (' ' authorship)?) {
      value = genus_name_or_abbreviation.value.merge subgenus_epithet.value
      value[:fossil] = true if fossil_flag
      value[:authorship] = authorship.value if authorship
      value
    }
  end

  rule genus_or_subgenus
     subgenus_name | genus_name_or_abbreviation
  end

  ###################################################################

  rule collective_group_label
    (genus_label &' (collective group name)') {
      value = {:collective_group_name => genus_label.value[:genus_name]}
      value[:fossil] = true if genus_label[:fossil]
      value
    }
  end

  rule collective_group_label_uppercase
    (genus_label_uppercase '') {
      value = {:collective_group_name => genus_label_uppercase.value[:genus_name]}
      value[:fossil] = true if genus_label_uppercase[:fossil]
      value
    }
  end

  ###################################################################

  rule species_group_epithet_label_list
    (species_group_epithet_label (', ' species_group_epithet_label)*) {
      captures[:species_group_epithet_label].map &:value
    }
  end

  rule species_group_epithet
    /[[:lower:]][[:lower:]\-][[:lower:]]*/ {
      {:species_group_epithet => to_s}
    }
  end

  rule species_epithet
    (species_group_epithet '') {
      {:species_epithet => species_group_epithet.value[:species_group_epithet]}
    }
  end

  rule subspecies_epithet
    (species_group_epithet '') {
      {:subspecies_epithet => species_group_epithet.value[:species_group_epithet]}
    }
  end

  rule italicized_subspecies_epithet
    (!italicized_term italic subspecies_epithet close_tag) {
        subspecies_epithet.value
    }
  end

  rule species_group_epithet_label
    (fossil_flag? italicized_species_group_epithet (' ' authorship)?) {
      value = italicized_species_group_epithet.value
      value[:fossil] = true if fossil_flag
      value[:authorship] = authorship.value if authorship
      value
    }
  end

  rule italicized_species_group_epithet
    (!italicized_term italic species_group_epithet close_tag) {
        species_group_epithet.value
    }
  end

  rule species_epithet_label
    (species_group_epithet_label '') {
      value = species_group_epithet_label.value
      value[:species_epithet] = value.delete :species_group_epithet
      value
    }
  end

  rule subspecies_epithet_label
    (species_group_epithet_label '') {
      value = species_group_epithet_label.value
      value[:subspecies_epithet] = value.delete :species_group_epithet
      value
    }
  end

  rule species_name
    (genus_or_subgenus ' ' species_epithet) {
      genus_or_subgenus.value.merge species_epithet.value
    }
  end

  rule species_label
    (fossil_flag? italic genus_or_subgenus ' ' '(?) '? species_epithet close_tag (' ' authorship)?) {
      value = genus_or_subgenus.value.merge species_epithet.value
      value[:fossil] = true if fossil_flag
      value[:authorship] = authorship.value if authorship
      value
    }
  end

  rule subspecies_label
    subspecies_with_types | subspecies_without_types
  end

  rule subspecies_without_types
    (fossil_flag? italic genus_or_subgenus ' ' species_epithet ' ' subspecies_epithet close_tag (' ' authorship)?) {
      value = genus_or_subgenus.value.merge species_epithet.value
      value[:subspecies] = [subspecies_epithet.value]
      value[:fossil] = true if fossil_flag
      value[:authorship] = authorship.value if authorship
      value
    }
  end

  rule subspecies_with_types
    (species_label (' ' subspecies_label_item)+ (' ' authorship)?) {
      value = species_label.value.merge :subspecies => captures[:subspecies_label_item].map(&:value)
      value[:authorship] = authorship.value if authorship
      value
    }
  end

  rule subspecies_label_item
    ( (subspecies_type ' ' italicized_subspecies_epithet) |
      (italicized_subspecies_epithet)) {
      value = {:subspecies_epithet => italicized_subspecies_epithet.value[:subspecies_epithet]}
      value[:type] = subspecies_type.value if subspecies_type
      value
    }
  end

  rule subspecies_type
    'var.' | 'var' | 'subsp.' | 'r.' | 'st.' | 'ab.' | 'form.' | 'natio' | 'nat.' | 'forma' | 'morpha' | 'subp.' | 'v.' |
      'f.interm.'
  end

  ####################################

  rule history_references
    (history_reference ('; ' history_reference)* ('; ' subsequent_authors)*) {
      value = captures[:history_reference].map(&:value)
      value << {:subsequent_authors => subsequent_authors.to_s} if subsequent_authors
      {:references => value}
    }
  end

  rule history_reference
    (reference (' ' bracketed_text)? ) {
      value = reference.value
      value.merge! bracketed_text.value if bracketed_text
      value
    }
  end

  rule subsequent_authors
      'all subsequent authors to the following'
    | ('all '? 'subsequent authors and ' reference)
    | 'all subsequent authors'
  end

end 
